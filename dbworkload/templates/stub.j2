import datetime as dt
import json
import string
from typing import Any
import psycopg
import random
import time
from uuid import uuid4

class {{ model.name }}:
    def __init__(self, args: dict):
        # args is a dict of string passed with the --args flag
        
        self.think_time: float = float(args.get("think_time", 5) / 1000)

        # you can arbitrarely add any variables you want
        self.my_var = 1

        # translation table for efficiently generating a string
        # -------------------------------------------------------
        # make translation table from 0..255 to A..Z, 0..9, a..z
        # the length must be 256
        self.tbl = bytes.maketrans(
            bytearray(range(256)),
            bytearray(
                [ord(b"a") + b % 26 for b in range(113)]
                + [ord(b"0") + b % 10 for b in range(30)]
                + [ord(b"A") + b % 26 for b in range(113)]
            ),
        )

    # the setup() function is executed only once
    # when a new executing thread is started.
    # Also, the function is a vector to receive the excuting threads's unique id and the total thread count
    def setup(self, conn: psycopg.Connection, id: int, total_thread_count: int):
        with conn.cursor() as cur:
            print(
                f"My thread ID is {id}. The total count of threads is {total_thread_count}"
            )
            print(cur.execute(f"select version()").fetchone()[0])

    # the loop() function returns a list of functions
    # that dbworkload will execute, sequentially.
    # Once every func has been executed, loop() is re-evaluated.
    # This process continues until dbworkload exits.
    def loop(self):
        return [
        {%- for x in range(model.txn_count) %}
            self.txn_{{x}},
        {%- endfor %}
        ]

    #####################
    # Utility Functions #
    #####################
    def __think__(self, conn: psycopg.Connection):
        time.sleep(self.think_time)

    def random_str(self, size: int = 12):
        return (
            random.getrandbits(8 * size)
            .to_bytes(size, "big")
            .translate(self.tbl)
            .decode()
        )

    # Workload function stubs
    {% for x in range(model.txn_count) %}
    def txn_{{ x }}(self, conn: psycopg.Connection):
        with conn.cursor() as cur:
            {%- set sql = model.txns[x] -%}
            {%- set statements = sql.split(';') -%}
            {%- set found_commit = false -%}
            {%- set skip_begin = true -%}
            {%- for stmt in statements -%}
                {%- set stmt_index = loop.index0 -%}
                {%- set stmt = stmt.strip() -%}
                {%- if stmt and not found_commit -%}
                    {%- if skip_begin and (stmt.upper() == 'BEGIN' or stmt.upper().startswith('BEGIN ')) -%}
                        {%- set skip_begin = false -%}
                    {%- elif stmt.upper() == 'COMMIT' -%}
                        {%- set found_commit = true -%}
                    {%- else %}
            cur.execute(
                """
                {{ stmt | indent(width=16) }}
                """,
                (
                {%- for bind_param in model.bind_params[x][stmt_index] %}
                    generate_random_value({{bind_param}}),
                {%- endfor %}
                ),
            ){% if model.txn_type[x] %}.fetchall(){% endif %}
                    {%- endif -%}
                {%- endif -%}
            {%- endfor %}
    {% endfor %}

def generate_random_value(field_name: str, data_type: str,is_null: str, is_pk: str) -> Any:
    """
    Generate a random value based on the provided data type.
    
    Args:
        data_type: The SQL data type.
        
    Returns:
        A random value of the appropriate type.
    """
    if data_type.lower() in ['int', 'int8', 'integer', 'bigint', 'smallint']:
        return random.randint(1, 1000)
    elif data_type.lower() in ['float', 'double', 'real', 'numeric', 'decimal']:
        return round(random.uniform(0, 1000), 2)
    elif data_type.lower() in ['varchar', 'char', 'text', 'string']:
        return ''.join(random.choices(string.ascii_letters + string.digits, k=10))
    elif data_type.lower() in ['date']:
        days = random.randint(0, 365)
        return (dt.datetime.now() - dt.timedelta(days=days)).strftime('%Y-%m-%d')
    elif data_type.lower() in ['timestamp', 'timestamptz', 'datetime']:
        days = random.randint(0, 365)
        hours = random.randint(0, 23)
        minutes = random.randint(0, 59)
        seconds = random.randint(0, 59)
        return (dt.datetime.now() - dt.timedelta(days=days, hours=hours, minutes=minutes, seconds=seconds)).strftime('%Y-%m-%d %H:%M:%S')
    elif data_type.lower() == 'interval':
        units = ['day', 'hour', 'minute', 'second', 'month', 'year']
        unit = random.choice(units)
        value = random.randint(1, 10)
        return f"{value} {unit}"
    elif data_type.lower() == 'boolean':
        return random.choice([True, False])
    elif data_type.lower() == 'uuid':
        return str(uuid4())
    elif data_type.lower() in ['json', 'jsonb']:
        keys = [''.join(random.choices(string.ascii_lowercase, k=5)) for _ in range(3)]
        values = [random.randint(1, 100) for _ in range(3)]
        return json.dumps(dict(zip(keys, values)))
    else:
        return ''.join(random.choices(string.ascii_letters + string.digits, k=10))

'''
# Quick random generators reminder

# random string of 25 chars
self.random_str(25),

# random int between 0 and 100k
random.randint(0, 100000),

# random float with 2 decimals 
round(random.random()*1000000, 2)

# now()
dt.datetime.utcnow()

# random timestamptz between certain dates,
# expressed as unix ts
dt.datetime.fromtimestamp(random.randint(1655032268, 1759232268))

# random UUID
uuid4()

# random bytes
size = 12
random.getrandbits(8 * size).to_bytes(size, "big")

'''
